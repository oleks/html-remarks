<!DOCTYPE HTML>
<!--
Copyright 2017 DIKU, Oleks
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Oleks name here nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html>
<head>
<title>Remarks</title>
<style type="text/css">
html input {
  font-family: monospace;
  font-size: 1.3em;
}
input {
  border: 0;
}
.mood {
  cursor: pointer; cursor: hand;
  padding: 0 0.5em;
  font-size: 1.5em;
  font-family: monospace;
}
h1 span, h2 span, h3 span, h4 span {
  padding-right: 0.3em;
}
.ps span {
  padding: 0 0.3em;
}
.ps input {
  width: 2em;
}
.ps .s {
  text-align: right;
}
.fill {
  width: 100%;
}
ol li {
  list-style-type: none;
}
ol li span {
  display: table-cell;
}
ol li input {
  width: 100%;
}
ol {
  padding: 0;
  padding-left: 1em;
}
.help_popup {
  display: none;
  position: fixed;
  z-index: 9998;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgb(0,0,0);
  background-color: rgba(0,0,0,0.4);
}
.help_fill {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}
.help {
  display: table;
  background-color: #fefefe;
  padding: 2em;
  width: 60%;
  position: fixed;
  top: 20%;
  left: 15%;
  z-index: 9999;
  border: 0.1em solid #fefefe;
  border-radius: 0.4em;
  -moz-border-radius: 0.4em;
  -webkit-border-radius: 0.4em;
}
.help_e {
  display: table-row;
  height: 1.6em;
}
.descr {
  display: table-cell;
  text-align: right;
}
.keys {
  display: table-cell;
}
.key {
  padding: 0.2em 0.3em;
  margin: 0 0.2em;
  color: #fff;
  background: #aaa;
  border: 0.1em solid #999;
  border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  -webkit-border-radius: 0.2em;
  font-family: monospace;
  font-weight: bold;
}
</style>
</head>
<body>
<div id="controls">
  <a href="#" onclick="showHelp();">Help</a>
</div>
<div id="help_popup" class="help_popup">
  <div class="help_fill" onclick="hideHelp()"></div>
  <div id="help" class="help"></div>
</div>
<div id="judgements"></div>
<div id="github">
  Made from <a href="https://github.com/oleks/html-remarks">oleks/html-remarks</a>, commit <a
href="https://github.com/oleks/html-remarks/commit/279ccc7a1929abdac17248c7d15ac31dd44ebc7d">279ccc7 (2017-11-22)</a>.
</div>
<script type="text/javascript">
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ctrl;
function byId(id) {
    return document.getElementById(id);
}
function toggleMoodText(current_mood) {
    var retval;
    switch (current_mood) {
        case "*":
            retval = "+";
            break;
        case "+":
            retval = "-";
            break;
        case "-":
            retval = "?";
            break;
        default:
            retval = "*";
            break;
    }
    return retval;
}
function toggleMood(elem) {
    elem.innerText = toggleMoodText(elem.innerText);
    elem.nextSibling.focus();
}
function htmlSection() {
    return document.createElement("section");
}
function htmlDiv() {
    return document.createElement("div");
}
function htmlSpan() {
    return document.createElement("span");
}
function htmlInput() {
    return document.createElement("input");
}
function htmlOList() {
    return document.createElement("ol");
}
function htmlLI() {
    return document.createElement("li");
}
function appendElement(c, container) {
    var element = c();
    container.appendChild(element);
    return element;
}
function insertElementAfter(c, container, prev) {
    var element = c();
    if (prev && prev.nextSibling) {
        container.insertBefore(element, prev.nextSibling);
    }
    else {
        container.appendChild(element);
    }
    return element;
}
function setValue(input) {
    input.setAttribute("value", input.value);
}
function appendTextInput(container) {
    var input = appendElement(htmlInput, container);
    input.setAttribute("type", "text");
    input.setAttribute("onchange", "setValue(this);");
    return input;
}
function appendRemarks(container) {
    return appendElement(htmlOList, container);
}
function appendMood(container) {
    var span = appendElement(htmlSpan, container);
    span.className = "mood";
    span.innerText = "*";
    span.setAttribute("onclick", "toggleMood(this);");
}
var TextField = (function () {
    function TextField(input) {
        this.input = input;
    }
    TextField.prototype.focus = function () {
        this.input.focus();
    };
    TextField.prototype.isEmpty = function () {
        return this.input.value.length === 0;
    };
    TextField.prototype.value = function () {
        return this.input.value;
    };
    return TextField;
}());
var Remark = (function (_super) {
    __extends(Remark, _super);
    function Remark(element) {
        var _this = _super.call(this, element.children[1].
            children[0]) || this;
        _this.element = element;
        return _this;
    }
    Remark.prototype.tryRemove = function (e) {
        if (!this.isEmpty()) {
            return;
        }
        var sibling = this.element.previousSibling ||
            this.element.nextSibling;
        if (sibling === null) {
            return;
        }
        detach(this.element);
        e.preventDefault();
        new Remark(sibling).focus();
    };
    Remark.prototype.indent = function () {
        var prev = this.element.previousSibling;
        if (prev) {
            var remarks = getRemarks(prev);
            detach(this.element);
            remarks.appendChild(this.element);
            this.input.focus();
        }
    };
    Remark.prototype.unindent = function () {
        var elem = this.element;
        if (elem.parentNode &&
            elem.parentNode.parentNode &&
            elem.parentNode.parentNode.parentNode) {
            var grandParent = elem.parentNode.parentNode;
            var container = grandParent.parentNode;
            if (container instanceof HTMLOListElement) {
                var next = grandParent.nextSibling;
                detach2(elem);
                if (next) {
                    container.insertBefore(elem, next);
                }
                else {
                    container.appendChild(elem);
                }
                this.input.focus();
            }
        }
    };
    return Remark;
}(TextField));
var Headed = (function (_super) {
    __extends(Headed, _super);
    function Headed(heading) {
        var _this = _super.call(this, heading.children[1].
            children[0]) || this;
        _this.heading = heading;
        _this.depth = parseInt(_this.heading.tagName.substring(1), 10);
        return _this;
    }
    return Headed;
}(TextField));
var Judgement = (function (_super) {
    __extends(Judgement, _super);
    function Judgement(element) {
        var _this = _super.call(this, element.children[0]) || this;
        _this.element = element;
        _this.remarks = element.children[1];
        return _this;
    }
    Judgement.prototype.isEmpty = function () {
        return _super.prototype.isEmpty.call(this) &&
            this.remarks.children.length === 1 &&
            new Remark(this.remarks.children[0]).isEmpty();
    };
    Judgement.prototype.tryRemove = function (e) {
        if (!this.isEmpty()) {
            return;
        }
        var sibling = this.element.previousSibling ||
            this.element.nextSibling;
        if (sibling === null) {
            return;
        }
        detach(this.element);
        e.preventDefault();
        new Judgement(sibling).focus();
    };
    return Judgement;
}(Headed));
function appendFillCell(container) {
    var fillCell = appendElement(htmlSpan, container);
    fillCell.className = "fill";
    return fillCell;
}
function appendRemark(container, prev) {
    var element = insertElementAfter(htmlLI, container, prev);
    appendMood(element);
    var fillCell = appendFillCell(element);
    var input = appendTextInput(fillCell);
    input.setAttribute("onkeydown", "remarkKeydown(event, this, this.parentNode.parentNode);");
    input.setAttribute("onkeyup", "keyup(event, this);");
    input.focus();
    return new Remark(element);
}
function repeatString(text, times) {
    return Array(times + 1).join(text);
}
var TextContainer = (function () {
    function TextContainer(container, text) {
        this.container = container;
        this.text = text;
    }
    TextContainer.prototype.element = function () {
        return this.container;
    };
    TextContainer.prototype.focus = function () {
        this.text.focus();
    };
    return TextContainer;
}());
function setGivenPoints(input) {
    setValue(input);
}
function setMaxPoints(input) {
    setValue(input);
}
function appendPoints(container) {
    var span = appendElement(htmlSpan, container);
    span.className = "ps";
    var prefix = appendElement(htmlSpan, span);
    prefix.innerText = ":";
    var givenPoints = appendTextInput(span);
    givenPoints.className = "s";
    givenPoints.setAttribute("value", "50");
    givenPoints.setAttribute("onchange", "setGivenPoints(this);");
    var sep = appendElement(htmlSpan, span);
    sep.innerText = "/";
    var maxPoints = appendTextInput(span);
    maxPoints.className = "t";
    maxPoints.setAttribute("value", "100");
    maxPoints.setAttribute("onchange", "setMaxPoints(this);");
}
function createJudgementHeader(depth, input) {
    var header = document.createElement("h" + depth);
    var span = appendElement(htmlSpan, header);
    span.innerText = repeatString("#", depth);
    var fillCell = appendFillCell(header);
    if (input) {
        fillCell.appendChild(input);
    }
    else {
        input = appendTextInput(fillCell);
        input.setAttribute("onkeydown", "judgementKeydown(event, this, this.parentNode.parentNode.parentNode);");
        input.setAttribute("onkeyup", "keyup(event, this);");
    }
    appendPoints(header);
    return new TextContainer(header, input);
}
function appendJudgement(container, depth, prev) {
    var judgement = insertElementAfter(htmlSection, container, prev);
    var header = createJudgementHeader(depth);
    judgement.appendChild(header.element());
    appendRemark(appendRemarks(judgement));
    header.focus();
}
function lastChild(elem) {
    if (elem.children.length === 0) {
        return null;
    }
    else {
        return elem.children[elem.children.length - 1];
    }
}
function findJudgements(elem) {
    var candidate = lastChild(elem);
    if (candidate instanceof HTMLDivElement) {
        return candidate;
    }
    else {
        return null;
    }
}
function getJudgements(elem) {
    var judgements = findJudgements(elem);
    if (judgements === null) {
        judgements = appendJudgements(elem);
    }
    return judgements;
}
function appendJudgements(container) {
    return appendElement(htmlDiv, container);
}
function appendJudgementAfter(judgement) {
    var depth = parseInt(judgement.children[0].tagName.substring(1), 10);
    var container = judgement.parentNode;
    appendJudgement(container, depth, judgement);
}
function findRemarks(elem) {
    var candidate = lastChild(elem);
    if (candidate instanceof HTMLOListElement) {
        return candidate;
    }
    else {
        return null;
    }
}
function getRemarks(elem) {
    var remarks = findRemarks(elem);
    if (remarks === null) {
        remarks = appendRemarks(elem);
    }
    return remarks;
}
function indentJudgementAux(judgement, input) {
    if (judgement.previousSibling === null) {
        return;
    }
    var sibling = judgement.previousSibling;
    if (sibling.tagName !== "SECTION") {
        return;
    }
    var judgements = getJudgements(sibling);
    detach(judgement);
    judgements.appendChild(judgement);
    var depth = (new Judgement(judgement)).depth;
    if (depth === 3) {
        return;
    }
    var header = createJudgementHeader(depth + 1, input);
    judgement.removeChild(judgement.children[0]);
    judgement.insertBefore(header.element(), judgement.children[0]);
}
function indentJudgement(judgement, input) {
    indentJudgementAux(judgement, input);
    input.focus();
}
function unindentJudgementAux(judgement, input) {
    var depth = (new Judgement(judgement)).depth;
    if (depth === 1) {
        return;
    }
    var container = judgement.parentNode;
    var parentJudgement = container.parentNode;
    var grandParent = parentJudgement.parentNode;
    var nextSibling = parentJudgement.nextSibling;
    detach2(judgement);
    if (nextSibling) {
        grandParent.insertBefore(judgement, nextSibling);
    }
    else {
        grandParent.appendChild(judgement);
    }
    var header = createJudgementHeader(depth - 1, input);
    judgement.removeChild(judgement.children[0]);
    judgement.insertBefore(header.element(), judgement.children[0]);
}
function unindentJudgement(judgement, input) {
    unindentJudgementAux(judgement, input);
    input.focus();
}
function moveUp(elem, focus) {
    var prev = elem.previousSibling;
    if (prev) {
        var container = elem.parentNode;
        container.removeChild(elem);
        container.insertBefore(elem, prev);
        focus.focus();
    }
}
function moveDown(elem, focus) {
    var next = elem.nextSibling;
    if (next) {
        var container = elem.parentNode;
        container.removeChild(elem);
        var nextnext = next.nextSibling;
        if (nextnext) {
            container.insertBefore(elem, nextnext);
        }
        else {
            container.appendChild(elem);
        }
        focus.focus();
    }
}
function detach(elem) {
    elem.parentNode.removeChild(elem);
}
function detach2(elem) {
    var container = elem.parentNode;
    detach(elem);
    if (container.children.length === 0) {
        detach(container);
    }
}
function remarkKeydown(e, input, remark) {
    if (e.code === "Enter") {
        var container = remark.parentNode;
        appendRemark(container, remark);
    }
    else if (e.code === "Backspace") {
        new Remark(remark).tryRemove(e);
    }
    else if (e.key === "Control") {
        ctrl = input;
    }
    else if (ctrl === input && e.code === "Space") {
        toggleMood(input.parentNode.
            previousSibling);
    }
    else if (ctrl === input && e.key === "ArrowRight") {
        new Remark(remark).indent();
    }
    else if (ctrl === input && e.key === "ArrowLeft") {
        new Remark(remark).unindent();
    }
    else if (ctrl === input && e.key === "ArrowUp") {
        moveUp(remark, input);
    }
    else if (ctrl === input && e.key === "ArrowDown") {
        moveDown(remark, input);
    }
}
function judgementKeydown(e, input, judgement) {
    if (e.code === "Enter") {
        appendJudgementAfter(judgement);
    }
    else if (e.code === "Backspace") {
        new Judgement(judgement).tryRemove(e);
    }
    else if (e.key === "Control") {
        ctrl = input;
    }
    else if (ctrl === input && e.key === "ArrowRight") {
        indentJudgement(judgement, input);
    }
    else if (ctrl === input && e.key === "ArrowLeft") {
        unindentJudgement(judgement, input);
    }
    else if (ctrl === input && e.key === "ArrowUp") {
        moveUp(judgement, input);
    }
    else if (ctrl === input && e.key === "ArrowDown") {
        moveDown(judgement, input);
    }
}
function keyup(e, elem) {
    if (ctrl === elem && e.key === "Control") {
        ctrl = null;
    }
}
function basename() {
    var parts = document.location.href.split("?")[0].split("/");
    var last = parts[parts.length - 1];
    return last.split(".html")[0];
}
function appendDescr(container, descr) {
    var descr_elem = appendElement(htmlSpan, container);
    descr_elem.className = "descr";
    descr_elem.innerHTML = descr + ":";
}
function appendKey(container, key) {
    var key_elem = appendElement(htmlSpan, container);
    key_elem.className = "key";
    key_elem.innerText = key;
}
function appendText(container, text) {
    container.innerHTML += text;
}
function addHelpEntry(container, descr, keys) {
    var entry = appendElement(htmlDiv, container);
    entry.className = "help_e";
    appendDescr(entry, descr);
    var keys_elem = appendElement(htmlSpan, entry);
    keys_elem.className = "keys";
    var last_ndx = keys.length - 1;
    if (last_ndx >= 0) {
        for (var i = 0; i < last_ndx; i++) {
            appendKey(keys_elem, keys[i]);
            appendText(keys_elem, '+');
        }
        appendKey(keys_elem, keys[last_ndx]);
    }
    keys = keys;
}
function addHelp() {
    var help = byId("help");
    addHelpEntry(help, "Save", ["Ctrl", "S"]);
    addHelpEntry(help, "Go to next input", ["Tab"]);
    addHelpEntry(help, "Go to previous input", ["Shift", "Tab"]);
    addHelpEntry(help, "Indent element right", ["Ctrl", "→"]);
    addHelpEntry(help, "Indent element left", ["Ctrl", "←"]);
    addHelpEntry(help, "Move element up", ["Ctrl", "↑"]);
    addHelpEntry(help, "Move element down", ["Ctrl", "↓"]);
    addHelpEntry(help, "Toggle mood (<tt>*/+/-/?</tt>)", ["Ctrl", "Space"]);
}
function helpKeydown(e) {
    if (e.key === "Escape") {
        hideHelp();
    }
}
function showHelp() {
    var popup = byId("help_popup");
    popup.style.display = "inline";
    document.addEventListener("keydown", helpKeydown);
}
function hideHelp() {
    var popup = byId("help_popup");
    popup.style.display = "none";
    document.addEventListener("keydown", helpKeydown);
}
function main() {
    document.title = basename();
    var judgements = byId("judgements");
    if (judgements.children.length === 0) {
        appendJudgement(judgements, 1);
    }
    addHelp();
}
main();
</script>
</body>
</html>
